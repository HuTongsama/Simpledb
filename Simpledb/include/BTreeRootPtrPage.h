#pragma once
#include"Page.h"
#include"BTreePageId.h"
namespace Simpledb {
	class BTreeRootPtrPage : public Page {
	public:
		// size of this page
		const static int PAGE_SIZE = 9;
		/**
		 * There is only one instance of a BTreeRootPtrPage per table. This static
		 * method is separate from getId() in order to maintain the Page interface
		 * @param tableid - the tableid of this table
		 * @return the root pointer page id for the given table
		 */
		static shared_ptr<BTreePageId> getId(size_t tableid);
		/**
		 * Static method to generate a byte array corresponding to an empty
		 * BTreeRootPtrPage.
		 * Used to add new, empty pages to the file. Passing the results of
		 * this method to the BTreeRootPtrPage constructor will create a BTreeRootPtrPage with
		 * no valid entries in it.
		 *
		 * @return The returned ByteArray.
		 */
		static vector<unsigned char> createEmptyPageData();
		static int getPageSize();
		/**
		 * Constructor.
		 * Construct the BTreeRootPtrPage from a set of bytes of data read from
		 * disk.
		 * The format of an BTreeRootPtrPage is an integer for the page number
		 * of the root node, followed by a byte to encode the category of the root page
		 * (either leaf or internal), followed by an integer for the page number
		 * of the first header page
		 */
		BTreeRootPtrPage(shared_ptr<BTreePageId> id, const vector<unsigned char>& data);
		void setBeforeImage()override;
		/**
		 * @return the PageId associated with this page.
		 */
		shared_ptr<PageId> getId()const override;
		/**
		 * Generates a byte array representing the contents of this root pointer page.
		 * Used to serialize this root pointer page to disk.
		 * The invariant here is that it should be possible to pass the byte array
		 * generated by getPageData to the BTreeRootPtrPage constructor and have it
		 * produce an identical BTreeRootPtrPage object.
		 *
		 * @return A byte array corresponding to the bytes of this root pointer page.
		 */
		vector<unsigned char> getPageData()override;
		void markDirty(bool dirty, shared_ptr<TransactionId> tid)override;
		shared_ptr<TransactionId> isDirty()const override;
		/** Return a view of this page before it was modified
		-- used by recovery */
		shared_ptr<Page> getBeforeImage()override;
		/**
		 * Get the id of the root page in this B+ tree
		 * @return the id of the root page
		 */
		shared_ptr<BTreePageId> getRootId();
		/**
		 * Set the id of the root page in this B+ tree
		 * @param id - the id of the root page
		 * @throws DbException if the id is invalid
		 */
		void setRootId(shared_ptr<BTreePageId> id);
		/**
		 * Get the id of the first header page, or null if none exists
		 * @return the id of the first header page
		 */
		shared_ptr<BTreePageId> getHeaderId();
		/**
		 * Set the page id of the first header page
		 * @param id - the id of the first header page
		 * @throws DbException if the id is invalid
		 */
		void setHeaderId(shared_ptr<BTreePageId> id);
	private:
		bool _dirty = false;
		shared_ptr<TransactionId> _dirtier = nullptr;
		shared_ptr<BTreePageId> _pid;
		int _root;
		int _rootCategory;
		int _header;
		vector<unsigned char> _oldData;

	};
}