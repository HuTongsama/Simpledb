#pragma once
#include"BTreePage.h"
#include"Tuple.h"
namespace Simpledb {
	/**
	 * Each instance of BTreeLeafPage stores data for one page of a BTreeFile and
	 * implements the Page interface that is used by BufferPool.
	 *
	 * @see BTreeFile
	 * @see BufferPool
	 *
	 */
	class BTreeLeafPage : public BTreePage {
	private:
		vector<unsigned char> _header;
		vector<shared_ptr<Tuple>> _tuples;
		int _numSlots;
		int _leftSibling;// leaf node or 0
		int _rightSibling;// leaf node or 0

		/**
		 * Computes the number of bytes in the header of a page in a BTreeFile with each tuple occupying tupleSize bytes
		 */
		int getHeaderSize();
		/**
		 * Read tuples from the source file.
		 */
		shared_ptr<Tuple> readNextTuple(DataStream& dis, int slotId);
		/**
		 * Move a record from one slot to another slot, and update the corresponding
		 * headers and RecordId
		 */
		void moveRecord(int from, int to);
		/**
		 * Abstraction to fill or clear a slot on this page.
		 */
		void markSlotUsed(int i, bool value);
	public:
		/**
		 * Create a BTreeLeafPage from a set of bytes of data read from disk.
		 * The format of a BTreeLeafPage is a set of header bytes indicating
		 * the slots of the page that are in use, and some number of tuple slots,
		 * as well as some extra bytes for the parent and sibling pointers.
		 *  Specifically, the number of tuples is equal to: <p>
		 *          floor((BufferPool.getPageSize()*8 - extra bytes*8) / (tuple size * 8 + 1))
		 * <p> where tuple size is the size of tuples in this
		 * database table, which can be determined via {@link Catalog#getTupleDesc}.
		 * The number of 8-bit header words is equal to:
		 * <p>
		 *      ceiling(no. tuple slots / 8)
		 * <p>
		 * @see Database#getCatalog
		 * @see Catalog#getTupleDesc
		 * @see BufferPool#getPageSize()
		 *
		 * @param id - the id of this page
		 * @param data - the raw data of this page
		 * @param key - the field which the index is keyed on
		 */
		BTreeLeafPage(shared_ptr<BTreePageId> id, const vector<unsigned char>& data, int key);

		void checkRep(int fieldid, shared_ptr<Field> lowerBound, shared_ptr<Field> upperBound, bool checkoccupancy, int depth);
		/**
		 * Retrieve the maximum number of tuples this page can hold.
		 */
		int getMaxTuples();
		/** Return a view of this page before it was modified
			-- used by recovery */
		shared_ptr<Page> getBeforeImage()override;
		void setBeforeImage()override;
		/**
		 * Generates a byte array representing the contents of this page.
		 * Used to serialize this page to disk.
		 * <p>
		 * The invariant here is that it should be possible to pass the byte
		 * array generated by getPageData to the BTreeLeafPage constructor and
		 * have it produce an identical BTreeLeafPage object.
		 *
		 * @see #BTreeLeafPage
		 * @return A byte array corresponding to the bytes of this page.
		 */
		vector<unsigned char> getPageData()override;
		/**
		 * Delete the specified tuple from the page;  the tuple should be updated to reflect
		 *   that it is no longer stored on any page.
		 * @throws runtimeError if this tuple is not on this page, or tuple slot is
		 *         already empty.
		 * @param t The tuple to delete
		 */
		void deleteTuple(shared_ptr<Tuple> t);
		/**
		 * Adds the specified tuple to the page such that all records remain in sorted order;
		 * the tuple should be updated to reflect
		 *  that it is now stored on this page.
		 * @throws runtimeError if the page is full (no empty slots) or tupledesc
		 *         is mismatch.
		 * @param t The tuple to add.
		 */
		void insertTuple(shared_ptr<Tuple> t);
		/**
		 * Get the id of the left sibling of this page
		 * @return the id of the left sibling
		 */
		shared_ptr<BTreePageId> getLeftSiblingId();
		/**
		 * Get the id of the right sibling of this page
		 * @return the id of the right sibling
		 */
		shared_ptr<BTreePageId> getRightSiblingId();
		/**
		 * Set the left sibling id of this page
		 * @param id - the new left sibling id
		 * @throws runtimeError if the id is not valid
		 */
		void setLeftSiblingId(shared_ptr<BTreePageId> id);
		/**
		 * Set the right sibling id of this page
		 * @param id - the new right sibling id
		 * @throws runtimeError if the id is not valid
		 */
		void setRightSiblingId(shared_ptr<BTreePageId> id);
		/**
		 * Returns the number of tuples currently stored on this page
		 */
		size_t getNumTuples();
		size_t getNumEmptySlots()override;
		bool isSlotUsed(size_t i)override;
		/**
		 * @return an iterator over all tuples on this page (calling remove on this iterator throws an UnsupportedOperationException)
		 * (note that this iterator shouldn't return tuples in empty slots!)
		 */
		shared_ptr<Iterator<shared_ptr<Tuple>>> iterator();
		/**
		 * @return a reverse iterator over all tuples on this page (calling remove on this iterator throws an UnsupportedOperationException)
		 * (note that this iterator shouldn't return tuples in empty slots!)
		 */
		shared_ptr<Iterator<shared_ptr<Tuple>>> reverseIterator();
		/**
		 * protected method used by the iterator to get the ith tuple out of this page
		 * @param i - the index of the tuple
		 * @return the ith tuple in the page
		 * @throws runtimeError
		 */
		shared_ptr<Tuple> getTuple(int i);

	};

	class BTreeLeafPageIterator :public Iterator<shared_ptr<Tuple>> {
	private:
		shared_ptr<Tuple> _nextToReturn;
		shared_ptr<BTreeLeafPage> _p;
	public:
		BTreeLeafPageIterator(shared_ptr<BTreeLeafPage> p);
		bool hasNext()override;
		shared_ptr<Tuple>& next()override;
		
	};

	class BTreeLeafPageReverseIterator :public Iterator<shared_ptr<Tuple>> {
	private:
		shared_ptr<Tuple> _nextToReturn;
		shared_ptr<BTreeLeafPage> _p;
	public:
		BTreeLeafPageReverseIterator(shared_ptr<BTreeLeafPage> p);
		bool hasNext()override;
		shared_ptr<Tuple>& next()override;

	};
}